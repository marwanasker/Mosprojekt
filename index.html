<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script>
			//FRAME RATE TAB
			(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame
				(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 ); //(fov, aspect ratio,near clipping plane,far clipping plane)
			var renderer = new THREE.WebGLRenderer(); // the three.js renderer
			renderer.setSize( window.innerWidth, window.innerHeight ); //setting the size of the renderer
			document.body.appendChild( renderer.domElement ); // add a render element to the browser


			//INTERACTIVE WINDOW SIZE
      window.addEventListener('resize', function()
      {
        var width = window.innerWidth;
        var height = window.innerHeight;
        renderer.setSize(width,height);
        camera.aspect = width/height;
        camera.updateProjectionMatrix();
      })
			//
			clock = new THREE.Clock();
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.basicShadowMap;

			function getRadians(){
				return -0.01;
			}

      controls = new THREE.OrbitControls(camera, renderer.domElement);  // set OrbitControls

			// add lightningt to the scene: hsl= hue/satuaration/lightness/level
			var keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'),1.0);
			keyLight.position.set(-100,0,100); //change posistion of the light source

			var fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 100%)'),0.75);
			fillLight.position.set(100,0,100);

			var backLight = new THREE.DirectionalLight(0xffffff, 1.0);
			backLight.position.set(100,0,-100).normalize();

			var ambientLight = new THREE.AmbientLight(new THREE.Color('rgb(255, 255, 255)') , 0.5); // soft white light

			pointLight = new THREE.PointLight(0xffffff,0.8,18);
			pointLight.position.set(3,3,15);
			pointLight.castShadow = true;
			pointLight.shadow.camera.near = 0.1;
			pointLight.shadow.camera.far = 25;

			scene.add(ambientLight);
			scene.add(pointLight);
			//scene.add(keyLight);
			//scene.add(fillLight);
			//scene.add(backLight);

			var geometry = new THREE.BoxGeometry( 100, 100, 1 ); // create the geometry for a cube with size 1,1,1 in x,y,z, BoxGeometry contains all the vertices for a cube
			var material = new THREE.MeshPhongMaterial( { color: 0x448afc, wireframe:false } ); // create a material to color the cube
			var cube = new THREE.Mesh( geometry, material ); // create a mesh, a mesh is an objects that takes a geometry and applies a material to it
			cube.receiveShadow = true;
			cube.translateZ(-0.8);
			scene.add(cube); // add the cube mesh to the scene we will be rendering

			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setTexturePath('/assets/');
			mtlLoader.setPath('/assets/');
			mtlLoader.load('cog2.mtl', function(materials){

				materials.preload();
				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath('/assets/');
				objLoader.load('cog2.obj', function(object){

				cog = object;
				cog.rotateZ(1.57079633);
				cog.rotateX(1.57079633)
				cog.receiveShadow = true;
				cog.castShadow = true;
				scene.add(cog)
				});
			});
			camera.position.z = 10; // move out in the z-plane so we don't clash with the cube

			var animate = function () { // create a render loop that updates the scene 60 times/sec (where the screen is refreshed)
				console.log(Math.round(clock.getElapsedTime()));

				requestAnimationFrame( animate ); //requestAnimationFrame is the same as setInterval but with a few advantages, one of them being that it stops when the user navigates to another tab
				cog.rotateY(getRadians());
				renderer.render( scene, camera ); // render the scene
			};

			animate(); // call the render loop
		</script>
	</body>
</html>
